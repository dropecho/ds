// Generated by Haxe 4.1.5
using haxe.root;

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.ds {
	public class ArraySort : global::haxe.lang.HxObject {
		
		public ArraySort(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public ArraySort() {
			global::haxe.ds.ArraySort.__hx_ctor_haxe_ds_ArraySort(this);
		}
		
		
		protected static void __hx_ctor_haxe_ds_ArraySort(global::haxe.ds.ArraySort __hx_this) {
		}
		
		
		public static void sort<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp) {
			global::haxe.ds.ArraySort.rec<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (0) ), ((int) (a.length) ));
		}
		
		
		public static void rec<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp, int @from, int to) {
			unchecked {
				int middle = ( ( @from + to ) >> 1 );
				if (( ( to - @from ) < 12 )) {
					if (( to <= @from )) {
						return;
					}
					
					{
						int _g = ( @from + 1 );
						while (( _g < to )) {
							int j = _g++;
							while (( j > @from )) {
								if (( ((int) (cmp.__hx_invoke2_f(default(double), a[j], default(double), a[( j - 1 )])) ) < 0 )) {
									global::haxe.ds.ArraySort.swap<T>(((global::haxe.root.Array<T>) (a) ), ((int) (( j - 1 )) ), ((int) (j) ));
								}
								else {
									break;
								}
								
								 -- j;
							}
							
						}
						
					}
					
					return;
				}
				
				global::haxe.ds.ArraySort.rec<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (@from) ), ((int) (middle) ));
				global::haxe.ds.ArraySort.rec<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (middle) ), ((int) (to) ));
				global::haxe.ds.ArraySort.doMerge<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (@from) ), ((int) (middle) ), ((int) (to) ), ((int) (( middle - @from )) ), ((int) (( to - middle )) ));
			}
		}
		
		
		public static void doMerge<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp, int @from, int pivot, int to, int len1, int len2) {
			unchecked {
				while (true) {
					int first_cut = default(int);
					int second_cut = default(int);
					int len11 = default(int);
					int len22 = default(int);
					if (( ( len1 == 0 ) || ( len2 == 0 ) )) {
						return;
					}
					
					if (( ( len1 + len2 ) == 2 )) {
						if (( ((int) (cmp.__hx_invoke2_f(default(double), a[pivot], default(double), a[@from])) ) < 0 )) {
							global::haxe.ds.ArraySort.swap<T>(((global::haxe.root.Array<T>) (a) ), ((int) (pivot) ), ((int) (@from) ));
						}
						
						return;
					}
					
					if (( len1 > len2 )) {
						len11 = ( len1 >> 1 );
						first_cut = ( @from + len11 );
						second_cut = global::haxe.ds.ArraySort.lower<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (pivot) ), ((int) (to) ), ((int) (first_cut) ));
						len22 = ( second_cut - pivot );
					}
					else {
						len22 = ( len2 >> 1 );
						second_cut = ( pivot + len22 );
						first_cut = global::haxe.ds.ArraySort.upper<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (@from) ), ((int) (pivot) ), ((int) (second_cut) ));
						len11 = ( first_cut - @from );
					}
					
					global::haxe.ds.ArraySort.rotate<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (first_cut) ), ((int) (pivot) ), ((int) (second_cut) ));
					int new_mid = ( first_cut + len22 );
					global::haxe.ds.ArraySort.doMerge<T>(((global::haxe.root.Array<T>) (a) ), ((global::haxe.lang.Function) (cmp) ), ((int) (@from) ), ((int) (first_cut) ), ((int) (new_mid) ), ((int) (len11) ), ((int) (len22) ));
					@from = new_mid;
					pivot = second_cut;
					len1 -= len11;
					len2 -= len22;
				}
				
			}
		}
		
		
		public static void rotate<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp, int @from, int mid, int to) {
			if (( ( @from == mid ) || ( mid == to ) )) {
				return;
			}
			
			int n = global::haxe.ds.ArraySort.gcd(( to - @from ), ( mid - @from ));
			while (( n-- != 0 )) {
				T val = a[( @from + n )];
				int shift = ( mid - @from );
				int p1 = ( @from + n );
				int p2 = ( ( @from + n ) + shift );
				while (( p2 != ( @from + n ) )) {
					a[p1] = a[p2];
					p1 = p2;
					if (( ( to - p2 ) > shift )) {
						p2 += shift;
					}
					else {
						p2 = ( @from + (( shift - (( to - p2 )) )) );
					}
					
				}
				
				a[p1] = val;
			}
			
		}
		
		
		public static int gcd(int m, int n) {
			while (( n != 0 )) {
				int t = ( m % n );
				m = n;
				n = t;
			}
			
			return m;
		}
		
		
		public static int upper<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp, int @from, int to, int val) {
			unchecked {
				int len = ( to - @from );
				int half = default(int);
				int mid = default(int);
				while (( len > 0 )) {
					half = ( len >> 1 );
					mid = ( @from + half );
					if (( ((int) (cmp.__hx_invoke2_f(default(double), a[val], default(double), a[mid])) ) < 0 )) {
						len = half;
					}
					else {
						@from = ( mid + 1 );
						len = ( ( len - half ) - 1 );
					}
					
				}
				
				return @from;
			}
		}
		
		
		public static int lower<T>(global::haxe.root.Array<T> a, global::haxe.lang.Function cmp, int @from, int to, int val) {
			unchecked {
				int len = ( to - @from );
				int half = default(int);
				int mid = default(int);
				while (( len > 0 )) {
					half = ( len >> 1 );
					mid = ( @from + half );
					if (( ((int) (cmp.__hx_invoke2_f(default(double), a[mid], default(double), a[val])) ) < 0 )) {
						@from = ( mid + 1 );
						len = ( ( len - half ) - 1 );
					}
					else {
						len = half;
					}
					
				}
				
				return @from;
			}
		}
		
		
		public static void swap<T>(global::haxe.root.Array<T> a, int i, int j) {
			T tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
		}
		
		
	}
}


