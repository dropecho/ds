// Generated by Haxe 4.1.4
(function ($hx_exports, $global) { "use strict";
$hx_exports["algos"] = $hx_exports["algos"] || {};
$hx_exports["graph"] = $hx_exports["graph"] || {};
class Lambda {
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
}
Lambda.__name__ = true;
Math.__name__ = true;
class Reflect {
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
Std.__name__ = true;
class dropecho_ds_GraphNode {
	constructor(value,id) {
		this.id = id != null ? id : Std.string(Std.random(10000000));
		this.value = value;
	}
	neighborIds() {
		return this.graph.neighborIds(this);
	}
	neighbors(filter) {
		return this.graph.neighbors(this,filter);
	}
	edgeData(toId) {
		return this.graph.edgeData(this.id,toId);
	}
}
$hx_exports["GraphNode"] = dropecho_ds_GraphNode;
dropecho_ds_GraphNode.__name__ = true;
class dropecho_ds_BSPNode extends dropecho_ds_GraphNode {
	constructor(value) {
		super(value);
	}
	createLeft(value) {
		return this.setLeft(new dropecho_ds_BSPNode(value));
	}
	createRight(value) {
		return this.setRight(new dropecho_ds_BSPNode(value));
	}
	setLeft(node) {
		this.left = node;
		node.parent = this;
		this.graph.addNode(node);
		this.graph.addUniEdge(this.id,node.id,"left");
		this.graph.addUniEdge(node.id,this.id,"parent");
		return node;
	}
	setRight(node) {
		this.right = node;
		node.parent = this;
		this.graph.addNode(node);
		this.graph.addUniEdge(this.id,node.id,"right");
		this.graph.addUniEdge(node.id,this.id,"parent");
		return node;
	}
	isLeaf() {
		if(this.right == null) {
			return this.left == null;
		} else {
			return false;
		}
	}
	isRoot() {
		return this.parent == null;
	}
	hasLeft() {
		return this.left != null;
	}
	hasRight() {
		return this.right != null;
	}
}
$hx_exports["BSPNode"] = dropecho_ds_BSPNode;
dropecho_ds_BSPNode.__name__ = true;
class dropecho_ds_Graph {
	constructor() {
		this.nodes = new haxe_ds_StringMap();
		this.edges = new haxe_ds_StringMap();
	}
	createNode(value) {
		return this.addNode(new dropecho_ds_GraphNode(value));
	}
	addNode(node) {
		this.nodes.h[node.id] = node;
		node.graph = this;
		return node;
	}
	addUniEdge(nodeId,otherId,data) {
		if(Object.prototype.hasOwnProperty.call(this.edges.h,nodeId)) {
			this.edges.h[nodeId].h[otherId] = data;
		} else {
			let _g = new haxe_ds_StringMap();
			_g.h[otherId] = data;
			this.edges.h[nodeId] = _g;
		}
	}
	addBiEdge(nodeId,otherId,data) {
		this.addUniEdge(nodeId,otherId,data);
		this.addUniEdge(otherId,nodeId,data);
	}
	remove(id) {
		let _this = this.nodes;
		if(Object.prototype.hasOwnProperty.call(_this.h,id)) {
			delete(_this.h[id]);
		}
	}
	neighbors(node,filter) {
		let _gthis = this;
		let _this = this.neighborIds(node,filter);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _gthis.nodes.h[_this[i]];
		}
		return result;
	}
	neighborIds(node,filter) {
		let edges = this.edges.h[node.id];
		if(edges == null) {
			return [];
		}
		let _g = [];
		let _g1 = haxe_ds_StringMap.kvIterator(edges.h);
		while(_g1.hasNext()) {
			let _g2 = _g1.next();
			let id = _g2.key;
			if(filter == null || filter(id,_g2.value)) {
				_g.push(id);
			} else {
				continue;
			}
		}
		haxe_ds_ArraySort.sort(_g,Reflect.compare);
		return _g;
	}
	edgeData(fromId,toId) {
		if(Object.prototype.hasOwnProperty.call(this.edges.h,fromId)) {
			return this.edges.h[fromId].h[toId];
		}
		return null;
	}
}
$hx_exports["Graph"] = dropecho_ds_Graph;
dropecho_ds_Graph.__name__ = true;
class dropecho_ds_BSPTree extends dropecho_ds_Graph {
	constructor(rootValue) {
		super();
		this.root = new dropecho_ds_BSPNode();
		this.root.value = rootValue;
		this.addNode(this.root);
	}
	getParent(node) {
		return this.neighbors(node,function(id,data) {
			return data == "parent";
		})[0];
	}
	getChildren(node) {
		return this.neighbors(node,function(id,data) {
			if(data != "left") {
				return data == "right";
			} else {
				return true;
			}
		});
	}
	getRoot() {
		return this.root;
	}
	getLeafs() {
		let _g = [];
		let node = haxe_ds_StringMap.valueIterator(this.nodes.h);
		while(node.hasNext()) {
			let node1 = node.next();
			if(this.getChildren(node1).length != 0) {
				continue;
			}
			_g.push(node1);
		}
		return _g;
	}
}
$hx_exports["BSPTree"] = dropecho_ds_BSPTree;
dropecho_ds_BSPTree.__name__ = true;
class dropecho_ds_Heap {
	constructor(compare) {
		this.compare = compare != null ? compare : function(a,b) {
			return Reflect.compare(a,b) < 0;
		};
		this.elements = [];
	}
	push(n) {
		this.set_value(this.elements.push(n) - 1,n);
	}
	set_value_obj(oldVal,newVal) {
		this.set_value(this.elements.indexOf(oldVal),newVal);
	}
	set_value(i,val) {
		this.elements[i] = val;
		while(i != 0 && this.compare(val,this.elements[this._getParent(i)])) {
			this._swap(i,this._getParent(i));
			i = this._getParent(i);
		}
	}
	pop() {
		if(this.elements.length == 0) {
			return null;
		}
		if(this.elements.length == 1) {
			return this.elements.shift();
		}
		let element = this.elements.shift();
		this._heapify(0);
		return element;
	}
	peek() {
		return this.elements[0];
	}
	size() {
		return this.elements.length;
	}
	_heapify(index) {
		let els = this.elements;
		let length = this.elements.length;
		let left = this._getLeft(index);
		let right = this._getRight(index);
		let top = index;
		if(left < length && this.compare(els[left],els[index])) {
			top = left;
		}
		if(right < length && this.compare(els[right],els[index])) {
			top = right;
		}
		if(top != index) {
			this._swap(index,top);
			this._heapify(top);
		}
	}
	_swap(a,b) {
		let temp = this.elements[a];
		this.elements[a] = this.elements[b];
		this.elements[b] = temp;
	}
	_getParent(index) {
		return (index - 1) / 2 | 0;
	}
	_getLeft(index) {
		return 2 * index + 1;
	}
	_getRight(index) {
		return 2 * index + 2;
	}
}
$hx_exports["Heap"] = dropecho_ds_Heap;
dropecho_ds_Heap.__name__ = true;
class dropecho_ds_algos_InOrderTraversal {
	constructor() {
		this.visited = [];
	}
	run(node,visitor) {
		if(node.left != null) {
			this.run(node.left,visitor);
		}
		if(visitor != null) {
			if(visitor(node)) {
				this.visited.push(node.id);
			} else {
				return this.visited;
			}
		} else {
			this.visited.push(node.id);
		}
		if(node.right != null) {
			this.run(node.right,visitor);
		}
		return this.visited;
	}
}
$hx_exports["algos"]["InOrderTraversal"] = dropecho_ds_algos_InOrderTraversal;
dropecho_ds_algos_InOrderTraversal.__name__ = true;
class dropecho_ds_algos_PostOrderTraversal {
	constructor() {
		this.visited = [];
	}
	run(node,visitor) {
		if(node.left != null) {
			this.run(node.left,visitor);
		}
		if(node.right != null) {
			this.run(node.right,visitor);
		}
		if(visitor != null) {
			if(visitor(node)) {
				this.visited.push(node.id);
			} else {
				return this.visited;
			}
		} else {
			this.visited.push(node.id);
		}
		return this.visited;
	}
}
$hx_exports["algos"]["PostOrderTraversal"] = dropecho_ds_algos_PostOrderTraversal;
dropecho_ds_algos_PostOrderTraversal.__name__ = true;
class dropecho_ds_algos_PreOrderTraversal {
	constructor() {
		this.visited = [];
	}
	run(node,visitor) {
		if(visitor != null) {
			if(visitor(node)) {
				this.visited.push(node.id);
			} else {
				return this.visited;
			}
		} else {
			this.visited.push(node.id);
		}
		if(node.left != null) {
			this.run(node.left,visitor);
		}
		if(node.right != null) {
			this.run(node.right,visitor);
		}
		return this.visited;
	}
}
$hx_exports["algos"]["PreOrderTraversal"] = dropecho_ds_algos_PreOrderTraversal;
dropecho_ds_algos_PreOrderTraversal.__name__ = true;
class dropecho_ds_graph_Search {
	static dijkstra(graph,node,distCalc) {
		let queue = new dropecho_ds_Heap(function(a,b) {
			return Reflect.compare(a.dist,b.dist) < 0;
		});
		let dist = new haxe_ds_ObjectMap();
		let prev = new haxe_ds_ObjectMap();
		if(distCalc == null) {
			distCalc = function(a,b) {
				return 1;
			};
		}
		dist.set(node,0);
		let n = haxe_ds_StringMap.valueIterator(graph.nodes.h);
		while(n.hasNext()) {
			let n1 = n.next();
			if(n1 != node) {
				dist.set(n1,Infinity);
				prev.set(n1,null);
			}
			queue.push({ node : n1, dist : dist.h[n1.__id__]});
		}
		while(queue.size() > 0) {
			let minDistNode = queue.pop().node;
			let _this = queue.elements;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i].node.id;
			}
			let existingIds = result;
			let neighbors = minDistNode.neighbors(function(id,data) {
				return existingIds.indexOf(id) >= 0;
			});
			let _g2 = 0;
			while(_g2 < neighbors.length) {
				let neighbor = neighbors[_g2];
				++_g2;
				let distanceToNeighbor = dist.h[minDistNode.__id__] + distCalc(minDistNode,neighbor);
				if(distanceToNeighbor <= dist.h[neighbor.__id__]) {
					dist.set(neighbor,distanceToNeighbor);
					prev.set(neighbor,minDistNode.id);
					queue.set_value_obj(Lambda.find(queue.elements,function(x) {
						return x.node == neighbor;
					}),{ node : neighbor, dist : dist.h[neighbor.__id__]});
				}
			}
		}
		return { distances : dist, path : prev};
	}
}
$hx_exports["graph"]["Search"] = dropecho_ds_graph_Search;
dropecho_ds_graph_Search.__name__ = true;
class dropecho_ds_graph_Traversal {
	static breadthFirst(node) {
		let visited = [];
		let toVisit = [];
		toVisit.push(node);
		while(toVisit.length > 0) {
			let next = toVisit.shift();
			if(visited.indexOf(next.id) == -1) {
				visited.push(next.id);
				let _g = 0;
				let _g1 = next.neighbors();
				while(_g < _g1.length) toVisit.push(_g1[_g++]);
			}
		}
		return visited;
	}
	static depthFirst(node) {
		let visited = [];
		if(visited.indexOf(node.id) == -1) {
			visited.push(node.id);
		} else {
			return null;
		}
		let _g = 0;
		let _g1 = node.neighbors();
		while(_g < _g1.length) dropecho_ds_graph_Traversal.depthFirst(_g1[_g++]);
		return visited;
	}
}
$hx_exports["graph"]["traversal"] = dropecho_ds_graph_Traversal;
dropecho_ds_graph_Traversal.__name__ = true;
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		let middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			let _g = from + 1;
			while(_g < to) {
				let j = _g++;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		while(true) {
			let first_cut;
			let second_cut;
			let len11;
			let len22;
			if(len1 == 0 || len2 == 0) {
				return;
			}
			if(len1 + len2 == 2) {
				if(cmp(a[pivot],a[from]) < 0) {
					haxe_ds_ArraySort.swap(a,pivot,from);
				}
				return;
			}
			if(len1 > len2) {
				len11 = len1 >> 1;
				first_cut = from + len11;
				second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
				len22 = second_cut - pivot;
			} else {
				len22 = len2 >> 1;
				second_cut = pivot + len22;
				first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
				len11 = first_cut - from;
			}
			haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
			let new_mid = first_cut + len22;
			haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
			from = new_mid;
			pivot = second_cut;
			len1 -= len11;
			len2 -= len22;
		}
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		let n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			let val = a[from + n];
			let shift = mid - from;
			let p1 = from + n;
			let p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			let t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		let tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
haxe_ds_ArraySort.__name__ = true;
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
}
haxe_ds_ObjectMap.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	static valueIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return h[keys[idx - 1]];
		}};
	}
	static kvIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			let k = keys[idx - 1];
			return { key : k, value : h[k]};
		}};
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
haxe_ds_ObjectMap.count = 0;
js_Boot.__toStr = ({ }).toString;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
